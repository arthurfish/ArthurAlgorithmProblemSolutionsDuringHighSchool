
# P1287

**2019-05-31 18:11:42**
    
# 盒子与球

## 题目描述

现有 $r$ 个互不相同的盒子和 $n$ 个互不相同的球，要将这 $n$ 个球放入 $r$ 个盒子中，且不允许有空盒子。请求出有多少种不同的放法。

两种放法不同当且仅当存在一个球使得该球在两种放法中放入了不同的盒子。

## 输入格式

输入只有一行两个整数，分别代表 $n$ 和 $r$。

## 输出格式

输出一行一个整数代表答案。

## 样例 #1

### 样例输入 #1

```
3 2
```

### 样例输出 #1

```
6
```

## 提示

#### 样例输入输出 1 解释

有两个盒子（编号为 $1, 2$）和三个球（编号为 $1, 2, 3$），共有六种方案，分别如下：

| 盒子编号 |   方案 1    |   方案 2    |   方案 3    |   方案 4    |   方案 5    |   方案 6    |
| :------: | :---------: | :---------: | :---------: | :---------: | :---------: | :---------: |
| 盒子 $1$ |  小球 $1$   |  小球 $2$   |  小球 $3$   | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |
| 盒子 $2$ | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |  小球 $1$   |  小球 $2$   |  小球 $3$   |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $0 \leq r \leq n \leq 10$，且答案小于 $2^{31}$。

# GCX的AC代码
```cpp
#include<iostream>
using namespace std;

int N, R;
int d[1024][1024] = {0};

int dp(int n, int r){
    if( r <= 0 || n < r)
	return 0;
    if(d[n][r] != 0)
	return d[n][r];
    if(n == r)
	return d[n][r] = 1;
    else
return d[n][r] = dp(n - 1, r - 1) + dp(n - 1, r) * r;
}

int fuck(int i){
    if(i == 1)
	return i;
    return i * fuck(i - 1);
}

int main(){
    cin >> N >> R;
    cout << dp(N, R) * fuck(R);
}

```

